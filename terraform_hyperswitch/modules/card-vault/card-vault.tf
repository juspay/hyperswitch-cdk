data "aws_ami" "amazon_linux_2_locker" {
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

locals {
  effective_locker_ec2_ami_id = var.locker_ec2_ami_id == null ? data.aws_ami.amazon_linux_2_locker.id : var.locker_ec2_ami_id
  env_file_s3_key             = "locker.env" # Name of the .env file in S3
}

# --- Locker Database (Aurora PostgreSQL) ---
resource "aws_security_group" "locker_db_sg" {
  name        = "${var.stack_prefix}-Locker-db-SG" # Matches CDK
  description = "Security group for Locker RDS Aurora cluster"
  vpc_id      = var.vpc_id
  tags        = var.tags
  # Ingress will be from Locker EC2 SG
}

resource "aws_db_subnet_group" "locker_db_sng" {
  name       = "${var.stack_prefix}-locker-db-sng"
  subnet_ids = var.locker_database_zone_subnet_ids
  tags       = var.tags
}

resource "aws_rds_cluster" "locker_db" {
  count = 1 # Always create if this module is invoked

  cluster_identifier              = "${var.stack_prefix}-locker-db-cluster"
  engine                          = "aurora-postgresql"
  engine_version                  = var.aurora_engine_version
  database_name                   = "locker" # Default from CDK
  master_username                 = var.db_user
  manage_master_user_password     = true # Let RDS manage password via Secrets Manager
  master_user_secret_kms_key_id   = var.locker_kms_key_arn # Encrypt the SM secret with Locker's KMS key
  port                            = var.db_port
  db_subnet_group_name            = aws_db_subnet_group.locker_db_sng.name
  vpc_security_group_ids          = [aws_security_group.locker_db_sg.id]
  skip_final_snapshot             = true # Matches CDK RemovalPolicy.DESTROY
  backup_retention_period         = 7    # Default, adjust if needed
  storage_encrypted               = true # Default
  # apply_immediately             = true
  tags = var.tags
  depends_on = [aws_secretsmanager_secret_version.locker_db_creds_version] # Ensure secret exists
}

resource "aws_rds_cluster_instance" "locker_db_instance" {
  count = 1 # Single writer instance for Locker DB

  identifier              = "${var.stack_prefix}-locker-db-instance"
  cluster_identifier      = aws_rds_cluster.locker_db[0].id
  instance_class          = var.aurora_instance_type
  engine                  = "aurora-postgresql"
  engine_version          = var.aurora_engine_version
  publicly_accessible     = false
  tags                    = var.tags
}

# Dependency resource for Locker DB secret
resource "aws_secretsmanager_secret_version" "locker_db_creds_version" {
  secret_id = var.locker_db_secrets_manager_arn
  # This ensures that the secret (and its initial version if created by SM module) exists
  # before RDS tries to use it for manage_master_user_password.
}


# --- Locker EC2 Instance ---
# RSA Key Pairs (generated by Terraform, then stored in SSM by this module)
resource "tls_private_key" "locker_pair" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

resource "tls_private_key" "tenant_pair" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

# Store keys in SSM Parameter Store
resource "aws_ssm_parameter" "tenant_private_key" {
  name        = "/${var.stack_prefix}/tenant/private_key-${random_id.ssm_suffix.hex}"
  description = "Tenant private key for Locker"
  type        = "SecureString" # Encrypt with default SSM KMS key
  value       = tls_private_key.tenant_pair.private_key_pem
  tags        = var.tags
}

resource "aws_ssm_parameter" "locker_public_key" {
  name        = "/${var.stack_prefix}/locker/public_key-${random_id.ssm_suffix.hex}"
  description = "Locker public key"
  type        = "String" # Public key, SecureString not strictly needed but ok
  value       = tls_private_key.locker_pair.public_key_pem
  tags        = var.tags
}

resource "random_id" "ssm_suffix" {
 byte_length = 8
}


# Lambda for KMS encryption of secrets and uploading .env to S3
data "archive_file" "locker_kms_encrypt_lambda_zip" {
  type        = "zip"
  source_file = "${path.module}/lambda_code/encryption.py"
  output_path = "${path.module}/lambda_code/encryption.zip"
}

resource "aws_lambda_function" "locker_kms_encrypt_lambda" {
  function_name = "${var.stack_prefix}-LockerKmsEncryptionLambda" # Matches CDK
  handler       = "encryption.lambda_handler"
  runtime       = "python3.9"
  role          = var.lambda_role_arn_for_kms_encryption
  timeout       = 900 # 15 minutes

  filename         = data.archive_file.locker_kms_encrypt_lambda_zip.output_path
  source_code_hash = data.archive_file.locker_kms_encrypt_lambda_zip.output_base64sha256

  vpc_config {
    subnet_ids         = var.locker_database_zone_subnet_ids # Needs access to KMS, S3, SM. VPC Endpoints recommended.
    security_group_ids = [aws_security_group.locker_db_sg.id] # Example, if it needs to talk to DB SG (unlikely for this lambda)
                                                             # More likely a generic Lambda SG or one with access to endpoints.
  }

  environment {
    variables = {
      SECRET_MANAGER_ARN = var.locker_secrets_manager_kms_data_arn
      ENV_BUCKET_NAME    = var.locker_env_s3_bucket_name
      ENV_FILE           = local.env_file_s3_key
    }
  }
  tags = var.tags
  depends_on = [
    # aws_secretsmanager_secret_version.locker_kms_data_secret_version # Ensure secret content is ready
    # This creates a circular dependency if the secret content itself depends on these RSA keys.
    # The secret content should be prepared with placeholders or direct values.
    # The Lambda reads the secret, which should contain the plain RSA keys.
  ]
}

# Trigger for the KMS encryption Lambda (simulates CDK CustomResource)
resource "null_resource" "trigger_locker_kms_encryption" {
  triggers = {
    # Run when relevant inputs change
    lambda_arn    = aws_lambda_function.locker_kms_encrypt_lambda.arn
    secret_arn    = var.locker_secrets_manager_kms_data_arn # Re-run if the source secret changes
    # Add other triggers if the content of the secret (e.g., RSA keys) changes and requires re-encryption.
    # For RSA keys generated by Terraform, their change will trigger this.
    locker_private_key_pem = tls_private_key.locker_pair.private_key_pem 
    tenant_public_key_pem  = tls_private_key.tenant_pair.public_key_pem
  }

  provisioner "local-exec" {
    command = <<EOT
aws lambda invoke \
  --function-name ${aws_lambda_function.locker_kms_encrypt_lambda.function_name} \
  --payload '{ "RequestType": "Create", "ResponseURL": "http://localhost", "StackId": "dummy", "RequestId": "dummy", "LogicalResourceId": "dummy" }' \
  response.json && cat response.json
EOT
  }
  depends_on = [aws_lambda_function.locker_kms_encrypt_lambda]
}


# Locker EC2 Instance
resource "aws_security_group" "locker_ec2_sg" {
  name        = "${var.stack_prefix}-Locker-SG" # Matches CDK
  description = "Security group for Locker EC2 instance"
  vpc_id      = var.vpc_id
  tags        = var.tags
  # Ingress rules will be added from consuming services (e.g., EKS, Jump Host)
}

resource "aws_key_pair" "locker_ec2_key" {
  key_name   = "${var.stack_prefix}-Locker-ec2-keypair" # Matches CDK
  public_key = tls_private_key.locker_ec2_ssh.public_key_openssh
  tags       = var.tags
}

resource "tls_private_key" "locker_ec2_ssh" {
  algorithm = "RSA"
  rsa_bits  = 4096
}

locals {
  locker_ec2_userdata = templatefile("${path.module}/templates/userdata_locker_ec2.sh.tpl", {
    env_s3_bucket_name = var.locker_env_s3_bucket_name
    env_file_key       = local.env_file_s3_key
  })
}

resource "aws_instance" "locker_ec2" {
  ami                         = local.effective_locker_ec2_ami_id
  instance_type               = var.locker_ec2_instance_type
  key_name                    = aws_key_pair.locker_ec2_key.key_name
  subnet_id                   = var.locker_server_zone_subnet_ids[0] # Assuming single instance in first subnet of the zone
  vpc_security_group_ids      = [aws_security_group.locker_ec2_sg.id]
  iam_instance_profile        = var.locker_iam_instance_profile_name
  user_data_base64            = base64encode(local.locker_ec2_userdata)
  associate_public_ip_address = false # Typically internal
  tags = merge(var.tags, { Name = "${var.stack_prefix}-locker-ec2" })

  depends_on = [null_resource.trigger_locker_kms_encryption] # Ensure .env file is uploaded to S3
}

# Allow Locker EC2 to connect to Locker DB
resource "aws_security_group_rule" "locker_ec2_to_db" {
  type                     = "ingress"
  from_port                = var.db_port
  to_port                  = var.db_port
  protocol                 = "tcp"
  source_security_group_id = aws_security_group.locker_ec2_sg.id
  security_group_id        = aws_security_group.locker_db_sg.id
  description              = "Allow Locker EC2 to connect to Locker DB"
}


# --- Optional Jump Host for Locker ---
resource "aws_key_pair" "jump_host_key" {
  count = var.enable_jump_host ? 1 : 0
  key_name   = "${var.stack_prefix}-LockerJump-ec2-keypair" # Matches CDK
  public_key = tls_private_key.jump_host_ssh[0].public_key_openssh
  tags       = var.tags
}

resource "tls_private_key" "jump_host_ssh" {
  count     = var.enable_jump_host ? 1 : 0
  algorithm = "RSA"
  rsa_bits  = 4096
}

resource "aws_security_group" "jump_host_sg" {
  count = var.enable_jump_host ? 1 : 0
  name        = "${var.stack_prefix}-locker-jump-sg" # Matches CDK
  description = "Security group for Locker Jump Host"
  vpc_id      = var.vpc_id
  tags        = var.tags

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"] # Allow SSH from anywhere
    description = "Allow SSH for Jump Host"
  }
  egress { # Allow jump host to connect to Locker EC2
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    destination_security_group_id = aws_security_group.locker_ec2_sg.id
    description = "Allow SSH from Jump Host to Locker EC2"
  }
   egress { # Allow jump host to connect to Locker EC2 on app port
    from_port   = 8080 # Assuming locker app port
    to_port     = 8080
    protocol    = "tcp"
    destination_security_group_id = aws_security_group.locker_ec2_sg.id
    description = "Allow App access from Jump Host to Locker EC2"
  }
}

resource "aws_instance" "jump_host" {
  count = var.enable_jump_host ? 1 : 0

  ami                         = data.aws_ami.amazon_linux_2_locker.id # Use same Amazon Linux 2
  instance_type               = var.jump_host_instance_type
  key_name                    = aws_key_pair.jump_host_key[0].key_name
  subnet_id                   = var.public_subnet_ids_for_jump_host[0] # Deploy in a public subnet
  vpc_security_group_ids      = [aws_security_group.jump_host_sg[0].id]
  associate_public_ip_address = true
  tags = merge(var.tags, { Name = "${var.stack_prefix}-Locker-Jump-Server" })
}

# Allow Locker EC2 to accept SSH and App connections from Jump Host SG
resource "aws_security_group_rule" "jump_to_locker_ssh" {
  count = var.enable_jump_host ? 1 : 0
  type                     = "ingress"
  from_port                = 22
  to_port                  = 22
  protocol                 = "tcp"
  source_security_group_id = aws_security_group.jump_host_sg[0].id
  security_group_id        = aws_security_group.locker_ec2_sg.id
  description              = "Allow SSH from Jump Host to Locker EC2"
}

resource "aws_security_group_rule" "jump_to_locker_app" {
  count = var.enable_jump_host ? 1 : 0
  type                     = "ingress"
  from_port                = 8080 # Assuming locker app port
  to_port                  = 8080
  protocol                 = "tcp"
  source_security_group_id = aws_security_group.jump_host_sg[0].id
  security_group_id        = aws_security_group.locker_ec2_sg.id
  description              = "Allow App access from Jump Host to Locker EC2"
}
